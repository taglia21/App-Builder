# Deployment Guide for Generated SaaS Applications

This guide provides instructions on how to deploy applications generated by the App-Builder system.

## üöÄ One-Click Deployment (Recommended)

The App-Builder CLI includes a comprehensive deployment engine that handles the heavy lifting for you.

### 1. Prerequisites
Ensure you have the following API keys set in your `.env` file (or environment):

```env
VERCEL_TOKEN=...       # For Frontend hosting
RENDER_API_KEY=...     # For Backend & Database hosting
OPENAI_API_KEY=...     # For AI Features (Optional)
```

### 2. Run the Deployment Command

From the root of the **App-Builder** repository:

```bash
python main.py deploy <path_to_generated_app> --frontend vercel --backend render --env production
```

**Example:**
```bash
python main.py deploy ./output/my_startup_app --frontend vercel --backend render
```

### 3. What Happens Next?
1.  **Frontend**: The CLI uploads your `frontend/` folder to **Vercel**, builds the Next.js app, and returns a live URL (e.g., `https://my-startup.vercel.app`).
2.  **Backend**: The CLI creates a new Web Service on **Render**, provisions a PostgreSQL database, and links them via environment variables.
3.  **Verification**: The system checks specific endpoints to ensure the app is live.

---

## üõ† Manual Deployment

If you prefer to deploy manually or use different providers, follow these steps.

### Frontend (Next.js)
The frontend is a standard Next.js 14 application located in the `frontend/` directory.

**Vercel (Standard):**
1.  Install Vercel CLI: `npm i -g vercel`
2.  Navigate to folder: `cd frontend`
3.  Login: `vercel login`
4.  Deploy: `vercel --prod`

**Netlify:**
1.  Drag and drop the `frontend` folder into the Netlify dashboard, OR
2.  Connect your GitHub repository and point to the `frontend` base directory.

### Backend (FastAPI + Celery)
The backend is a Dockerized Python application with a PostgreSQL dependency.

**Render:**
1.  Create a **New Web Service**.
2.  Connect your repository.
3.  **Root Directory**: `backend`
4.  **Build Command**: `pip install -r requirements.txt`
5.  **Start Command**: `uvicorn app.main:app --host 0.0.0.0 --port 10000`
6.  **Environment Variables**:
    -   `DATABASE_URL`: (Connect a Render Managed Postgres instance)
    -   `REDIS_URL`: (Connect a Render Redis instance for Celery)

**Docker / VPS:**
You can deploy to any VPS (DigitalOcean, EC2) using Docker Compose:

1.  Copy `docker-compose.yml` and the `backend/` folder to your server.
2.  Run:
    ```bash
    docker-compose up -d --build
    ```

---

## üí∞ Cost Estimation

Before deploying, you can estimate the monthly infrastructure costs using the CLI:

```bash
python main.py estimate-cost <path_to_generated_app>
```

This will analyze the generated architecture (e.g., does it need high-RAM workers for AI?) and output an estimated monthly bill for Vercel + Render.

---

## üîß Infrastructure as Code (Terraform)

For enterprise-grade deployments on AWS, Terraform templates are generated in the `terraform/` directory of your application.

1.  Install Terraform.
2.  Navigate to `terraform/`.
3.  Run `terraform init`.
4.  Run `terraform apply`.

This will provision:
-   **AWS ECS**: Container orchestration.
-   **AWS RDS**: Managed PostgreSQL.
-   **AWS ElastiCache**: Managed Redis.
-   **AWS S3**: Static asset storage.

---

## üí• Chaos Engineering

The application includes a built-in Chaos Engineering middleware to simulate production failures and latency. This allows you to verify system resilience and rollback mechanisms.

### Control API

You can control chaos settings dynamically via the API (no restart required).

| Method | Endpoint | Description |
| :--- | :--- | :--- |
| `POST` | `/api/v1/chaos/enable` | Enable chaos with specific latency/error rates |
| `POST` | `/api/v1/chaos/disable` | Disable chaos mode |
| `GET` | `/api/v1/chaos/status` | Check current chaos settings |

### Example Usage

**1. Introduce 200ms Latency:**
```bash
curl -X POST "http://localhost:8000/api/v1/chaos/enable" \
     -H "Content-Type: application/json" \
     -d '{"latency_ms": 200, "error_rate": 0.0}'
```

**2. Introduce 5% Random 500 Errors:**
```bash
curl -X POST "http://localhost:8000/api/v1/chaos/enable" \
     -H "Content-Type: application/json" \
     -d '{"latency_ms": 0, "error_rate": 0.05}'
```

**3. Disable Chaos:**
```bash
curl -X POST "http://localhost:8000/api/v1/chaos/disable"
```

## ‚ùì Troubleshooting

**"Frontend build failed: Type errors"**
-   Run `npm run type-check` in the frontend directory locally.
-   Ensure generated types satisfy the Zod schemas.

**"Backend connection refused"**
-   Ensure `NEXT_PUBLIC_API_URL` in the frontend environment matches the deployed backend URL.
-   Check CORS settings in `backend/app/main.py`.
