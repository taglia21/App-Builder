# Deployment Guide for Generated SaaS Applications

This guide provides instructions on how to deploy applications generated by the App-Builder system.

## ÔøΩ Pre-Deployment Checklist

Before deploying to production, ensure you have completed:

- [ ] **Environment Variables**: All required env vars configured (see `.env.production.template`)
- [ ] **Database Migrations**: Run `alembic upgrade head` on production database
- [ ] **SSL Certificate**: Domain configured with SSL (most platforms handle this automatically)
- [ ] **Stripe Webhooks**: Production webhook endpoint configured in Stripe Dashboard
- [ ] **Email Service**: Resend.com account verified and API key set
- [ ] **DNS Configuration**: Domain pointed to your hosting provider
- [ ] **Error Tracking**: Sentry DSN configured for production
- [ ] **Backup Strategy**: Database backups enabled

---

## üöÇ Railway Deployment (Recommended)

Railway is the recommended platform for Valeric apps due to its simplicity and PostgreSQL/Redis support.

### Step 1: Create Railway Account
1. Go to [railway.app](https://railway.app)
2. Sign up with GitHub (recommended for easy repo access)

### Step 2: Create New Project
```bash
# Option A: Deploy from GitHub
# Click "New Project" ‚Üí "Deploy from GitHub repo" ‚Üí Select your repo

# Option B: Deploy with Railway CLI
npm i -g @railway/cli
railway login
railway init
railway up
```

### Step 3: Add PostgreSQL Database
1. In your Railway project, click **"+ New"**
2. Select **"Database"** ‚Üí **"PostgreSQL"**
3. Railway will automatically create `DATABASE_URL` environment variable

### Step 4: Add Redis
1. Click **"+ New"** ‚Üí **"Database"** ‚Üí **"Redis"**
2. `REDIS_URL` will be automatically configured

### Step 5: Configure Environment Variables
1. Click on your service
2. Go to **"Variables"** tab
3. Add all required variables from `.env.production.template`:

```env
# Required variables
STRIPE_SECRET_KEY=sk_live_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx
OPENAI_API_KEY=sk-xxx
JWT_SECRET_KEY=xxx
RESEND_API_KEY=re_xxx
```

### Step 6: Configure Custom Domain
1. Go to **"Settings"** ‚Üí **"Networking"**
2. Click **"Generate Domain"** for a `.railway.app` subdomain, OR
3. Click **"Custom Domain"** to add your own domain
4. Update DNS records as instructed

### Step 7: Run Database Migrations
```bash
# Option A: Via Railway CLI
railway run alembic upgrade head

# Option B: Via Railway dashboard
# Add a one-time deploy command in Procfile:
# release: alembic upgrade head
```

### Step 8: Verify Deployment
1. Visit your Railway URL
2. Check the health endpoint: `https://your-app.railway.app/health`
3. Expected response: `{"status": "healthy"}`

---

## ÔøΩüöÄ One-Click Deployment (Recommended)

The App-Builder CLI includes a comprehensive deployment engine that handles the heavy lifting for you.

### 1. Prerequisites
Ensure you have the following API keys set in your `.env` file (or environment):

```env
VERCEL_TOKEN=...       # For Frontend hosting
RENDER_API_KEY=...     # For Backend & Database hosting
OPENAI_API_KEY=...     # For AI Features (Optional)
```

### 2. Run the Deployment Command

From the root of the **App-Builder** repository:

```bash
python main.py deploy <path_to_generated_app> --frontend vercel --backend render --env production
```

**Example:**
```bash
python main.py deploy ./output/my_startup_app --frontend vercel --backend render
```

### 3. What Happens Next?
1.  **Frontend**: The CLI uploads your `frontend/` folder to **Vercel**, builds the Next.js app, and returns a live URL (e.g., `https://my-startup.vercel.app`).
2.  **Backend**: The CLI creates a new Web Service on **Render**, provisions a PostgreSQL database, and links them via environment variables.
3.  **Verification**: The system checks specific endpoints to ensure the app is live.

---

## üõ† Manual Deployment

If you prefer to deploy manually or use different providers, follow these steps.

### Frontend (Next.js)
The frontend is a standard Next.js 14 application located in the `frontend/` directory.

**Vercel (Standard):**
1.  Install Vercel CLI: `npm i -g vercel`
2.  Navigate to folder: `cd frontend`
3.  Login: `vercel login`
4.  Deploy: `vercel --prod`

**Netlify:**
1.  Drag and drop the `frontend` folder into the Netlify dashboard, OR
2.  Connect your GitHub repository and point to the `frontend` base directory.

### Backend (FastAPI + Celery)
The backend is a Dockerized Python application with a PostgreSQL dependency.

**Render:**
1.  Create a **New Web Service**.
2.  Connect your repository.
3.  **Root Directory**: `backend`
4.  **Build Command**: `pip install -r requirements.txt`
5.  **Start Command**: `uvicorn app.main:app --host 0.0.0.0 --port 10000`
6.  **Environment Variables**:
    -   `DATABASE_URL`: (Connect a Render Managed Postgres instance)
    -   `REDIS_URL`: (Connect a Render Redis instance for Celery)

**Docker / VPS:**
You can deploy to any VPS (DigitalOcean, EC2) using Docker Compose:

1.  Copy `docker-compose.yml` and the `backend/` folder to your server.
2.  Run:
    ```bash
    docker-compose up -d --build
    ```

---

## üí∞ Cost Estimation

Before deploying, you can estimate the monthly infrastructure costs using the CLI:

```bash
python main.py estimate-cost <path_to_generated_app>
```

This will analyze the generated architecture (e.g., does it need high-RAM workers for AI?) and output an estimated monthly bill for Vercel + Render.

---

## üîß Infrastructure as Code (Terraform)

For enterprise-grade deployments on AWS, Terraform templates are generated in the `terraform/` directory of your application.

1.  Install Terraform.
2.  Navigate to `terraform/`.
3.  Run `terraform init`.
4.  Run `terraform apply`.

This will provision:
-   **AWS ECS**: Container orchestration.
-   **AWS RDS**: Managed PostgreSQL.
-   **AWS ElastiCache**: Managed Redis.
-   **AWS S3**: Static asset storage.

---

## üí• Chaos Engineering

The application includes a built-in Chaos Engineering middleware to simulate production failures and latency. This allows you to verify system resilience and rollback mechanisms.

### Control API

You can control chaos settings dynamically via the API (no restart required).

| Method | Endpoint | Description |
| :--- | :--- | :--- |
| `POST` | `/api/v1/chaos/enable` | Enable chaos with specific latency/error rates |
| `POST` | `/api/v1/chaos/disable` | Disable chaos mode |
| `GET` | `/api/v1/chaos/status` | Check current chaos settings |

### Example Usage

**1. Introduce 200ms Latency:**
```bash
curl -X POST "http://localhost:8000/api/v1/chaos/enable" \
     -H "Content-Type: application/json" \
     -d '{"latency_ms": 200, "error_rate": 0.0}'
```

**2. Introduce 5% Random 500 Errors:**
```bash
curl -X POST "http://localhost:8000/api/v1/chaos/enable" \
     -H "Content-Type: application/json" \
     -d '{"latency_ms": 0, "error_rate": 0.05}'
```

**3. Disable Chaos:**
```bash
curl -X POST "http://localhost:8000/api/v1/chaos/disable"
```

## ‚ùì Troubleshooting

**"Frontend build failed: Type errors"**
-   Run `npm run type-check` in the frontend directory locally.
-   Ensure generated types satisfy the Zod schemas.

**"Backend connection refused"**
-   Ensure `NEXT_PUBLIC_API_URL` in the frontend environment matches the deployed backend URL.
-   Check CORS settings in `backend/app/main.py`.
