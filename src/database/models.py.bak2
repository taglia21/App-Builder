"""
LaunchForge Database Models

SQLAlchemy ORM models for PostgreSQL/SQLite database.
Includes users, projects, generations, and deployments.
Uses database-agnostic types for cross-platform compatibility.
"""

import enum
from datetime import datetime, timezone
from typing import List, Optional, Any
from uuid import uuid4

from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Enum,
    ForeignKey,
    Index,
    Integer,
    String,
    Text,
    func,
    text,
    JSON,
    TypeDecorator,
)
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship


# Cross-database compatible JSON type
class JSONType(TypeDecorator):
    """Database-agnostic JSON type. Uses JSONB on PostgreSQL, JSON elsewhere."""
    impl = JSON
    cache_ok = True
    
    def load_dialect_impl(self, dialect):
        if dialect.name == 'postgresql':
            from sqlalchemy.dialects.postgresql import JSONB
            return dialect.type_descriptor(JSONB())
        return dialect.type_descriptor(JSON())


class Base(DeclarativeBase):
    """Base class for all database models."""
    type_annotation_map = {
        dict: JSONType,
        list: JSONType,
    }


class SubscriptionTier(enum.Enum):
    """User subscription tiers."""
    FREE = "free"
    STARTER = "starter"
    PRO = "pro"
    ENTERPRISE = "enterprise"


class ProjectStatus(enum.Enum):
    """Project lifecycle status."""
    DRAFT = "draft"
    GENERATING = "generating"
    GENERATED = "generated"
    DEPLOYING = "deploying"
    DEPLOYED = "deployed"
    FAILED = "failed"
    ARCHIVED = "archived"


class DeploymentStatus(enum.Enum):
    """Deployment status."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    ROLLED_BACK = "rolled_back"


class TimestampMixin:
    """Mixin for created_at and updated_at timestamps."""
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False
    )


class SoftDeleteMixin:
    """Mixin for soft delete functionality."""
    deleted_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        default=None
    )
    is_deleted: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )

    def soft_delete(self) -> None:
        """Mark record as deleted."""
        self.deleted_at = datetime.now(timezone.utc)
        self.is_deleted = True

    def restore(self) -> None:
        """Restore a soft-deleted record."""
        self.deleted_at = None
        self.is_deleted = False


class User(Base, TimestampMixin, SoftDeleteMixin):
    """
    User model for LaunchForge accounts.
    
    Attributes:
        id: Unique user identifier (UUID)
        email: User email address (unique)
        password_hash: Bcrypt password hash
        subscription_tier: Current subscription level
        credits_remaining: API credits available
        email_verified: Whether email is verified
        last_login_at: Last login timestamp
    """
    __tablename__ = "users"

    id: Mapped[str] = mapped_column(
        String(36),  # UUID as string for cross-DB compatibility
        primary_key=True,
        default=lambda: str(uuid4())
    )
    email: Mapped[str] = mapped_column(
        String(255),
        unique=True,
        nullable=False,
        index=True
    )
    password_hash: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )
    subscription_tier: Mapped[SubscriptionTier] = mapped_column(
        Enum(SubscriptionTier),
        default=SubscriptionTier.FREE,
        nullable=False
    )
    credits_remaining: Mapped[int] = mapped_column(
        Integer,
        default=100,  # Free tier gets 100 credits
        nullable=False
    )
    email_verified: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )
    last_login_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    
    # Authentication fields
    name: Mapped[Optional[str]] = mapped_column(
        String(255),
        nullable=True
    )
    verification_token: Mapped[Optional[str]] = mapped_column(
        String(128),
        nullable=True
    )
    reset_token: Mapped[Optional[str]] = mapped_column(
        String(128),
        nullable=True
    )
    reset_token_expires: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    
    # OAuth fields
    oauth_provider: Mapped[Optional[str]] = mapped_column(
        String(50),
        nullable=True
    )
    oauth_id: Mapped[Optional[str]] = mapped_column(
        String(255),
        nullable=True
    )

    # Relationships
    projects: Mapped[List["Project"]] = relationship(
        "Project",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="dynamic"
    )
    
    # Subscription relationship
    subscription: Mapped[Optional["Subscription"]] = relationship(
        "Subscription",
        back_populates="user",
        uselist=False,
        lazy="joined"
    )
    
    # API Keys relationship
    api_keys: Mapped[List["APIKey"]] = relationship(
        "APIKey",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="dynamic"
    )
    
    # Business Formations relationship
    business_formations: Mapped[List["BusinessFormation"]] = relationship(
        "BusinessFormation",
        back_populates="user",
        cascade="all, delete-orphan",
        lazy="dynamic"
    )

    # Indexes
    __table_args__ = (
        Index("idx_users_email_verified", "email", "email_verified"),
        Index("idx_users_subscription", "subscription_tier"),
        Index("idx_users_not_deleted", "is_deleted", postgresql_where=text("is_deleted = false")),
    )

    def __repr__(self) -> str:
        return f"<User(id={self.id}, email={self.email}, tier={self.subscription_tier.value})>"

    def has_credits(self, amount: int = 1) -> bool:
        """Check if user has enough credits."""
        return self.credits_remaining >= amount

    def use_credits(self, amount: int = 1) -> bool:
        """Deduct credits from user. Returns False if insufficient."""
        if not self.has_credits(amount):
            return False
        self.credits_remaining -= amount
        return True


class Project(Base, TimestampMixin, SoftDeleteMixin):
    """
    Project model for user-created applications.
    
    Attributes:
        id: Unique project identifier (UUID)
        user_id: Owner user ID
        name: Project name
        description: Project description
        status: Current project status
        code_url: URL to generated code (GitHub, etc.)
        deployment_url: Live deployment URL
        config: Project configuration (JSON)
    """
    __tablename__ = "projects"

    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4())
    )
    user_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    name: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )
    description: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True
    )
    status: Mapped[ProjectStatus] = mapped_column(
        Enum(ProjectStatus),
        default=ProjectStatus.DRAFT,
        nullable=False
    )
    code_url: Mapped[Optional[str]] = mapped_column(
        String(500),
        nullable=True
    )
    deployment_url: Mapped[Optional[str]] = mapped_column(
        String(500),
        nullable=True
    )
    config: Mapped[Optional[dict]] = mapped_column(
        JSONType,
        nullable=True,
        default=dict
    )

    # Relationships
    user: Mapped["User"] = relationship(
        "User",
        back_populates="projects"
    )
    generations: Mapped[List["Generation"]] = relationship(
        "Generation",
        back_populates="project",
        cascade="all, delete-orphan",
        lazy="dynamic",
        order_by="desc(Generation.created_at)"
    )
    deployments: Mapped[List["Deployment"]] = relationship(
        "Deployment",
        back_populates="project",
        cascade="all, delete-orphan",
        lazy="dynamic",
        order_by="desc(Deployment.created_at)"
    )

    # Indexes
    __table_args__ = (
        Index("idx_projects_user_status", "user_id", "status"),
        Index("idx_projects_name", "name"),
        Index("idx_projects_not_deleted", "is_deleted", postgresql_where=text("is_deleted = false")),
    )

    def __repr__(self) -> str:
        return f"<Project(id={self.id}, name={self.name}, status={self.status.value})>"


class Generation(Base, TimestampMixin):
    """
    Generation model for AI-generated content.
    
    Tracks each generation request including prompts, 
    market intelligence, and generated code.
    
    Attributes:
        id: Unique generation identifier (UUID)
        project_id: Parent project ID
        prompt: User prompt/request
        market_intel: Market research data (JSON)
        generated_code: Generated code/content (JSON)
        tokens_used: LLM tokens consumed
        model_used: AI model identifier
        generation_time_ms: Time taken to generate
    """
    __tablename__ = "generations"

    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4())
    )
    project_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("projects.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    prompt: Mapped[str] = mapped_column(
        Text,
        nullable=False
    )
    market_intel: Mapped[Optional[dict]] = mapped_column(
        JSONType,
        nullable=True
    )
    generated_code: Mapped[Optional[dict]] = mapped_column(
        JSONType,
        nullable=True
    )
    tokens_used: Mapped[int] = mapped_column(
        Integer,
        default=0,
        nullable=False
    )
    model_used: Mapped[Optional[str]] = mapped_column(
        String(100),
        nullable=True
    )
    generation_time_ms: Mapped[Optional[int]] = mapped_column(
        Integer,
        nullable=True
    )
    error_message: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True
    )

    # Relationships
    project: Mapped["Project"] = relationship(
        "Project",
        back_populates="generations"
    )

    # Indexes
    __table_args__ = (
        Index("idx_generations_project_created", "project_id", "created_at"),
        Index("idx_generations_model", "model_used"),
    )

    def __repr__(self) -> str:
        return f"<Generation(id={self.id}, tokens={self.tokens_used})>"


class Deployment(Base, TimestampMixin):
    """
    Deployment model for project deployments.
    
    Tracks deployment attempts to various providers
    (Vercel, Netlify, Railway, etc.)
    
    Attributes:
        id: Unique deployment identifier (UUID)
        project_id: Parent project ID
        provider: Deployment provider name
        status: Current deployment status
        url: Live deployment URL
        logs: Deployment logs (JSON array)
        deployed_at: Successful deployment timestamp
        config: Provider-specific config (JSON)
    """
    __tablename__ = "deployments"

    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4())
    )
    project_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("projects.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    provider: Mapped[str] = mapped_column(
        String(50),
        nullable=False
    )
    status: Mapped[DeploymentStatus] = mapped_column(
        Enum(DeploymentStatus),
        default=DeploymentStatus.PENDING,
        nullable=False
    )
    url: Mapped[Optional[str]] = mapped_column(
        String(500),
        nullable=True
    )
    logs: Mapped[Optional[list]] = mapped_column(
        JSONType,
        nullable=True,
        default=list
    )
    deployed_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    config: Mapped[Optional[dict]] = mapped_column(
        JSONType,
        nullable=True
    )
    error_message: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True
    )
    build_duration_ms: Mapped[Optional[int]] = mapped_column(
        Integer,
        nullable=True
    )

    # Relationships
    project: Mapped["Project"] = relationship(
        "Project",
        back_populates="deployments"
    )

    # Indexes
    __table_args__ = (
        Index("idx_deployments_project_status", "project_id", "status"),
        Index("idx_deployments_provider", "provider"),
        Index("idx_deployments_deployed_at", "deployed_at"),
    )

    def __repr__(self) -> str:
        return f"<Deployment(id={self.id}, provider={self.provider}, status={self.status.value})>"

    def mark_success(self, url: str) -> None:
        """Mark deployment as successful."""
        self.status = DeploymentStatus.SUCCESS
        self.url = url
        self.deployed_at = datetime.now(timezone.utc)

    def mark_failed(self, error: str) -> None:
        """Mark deployment as failed."""
        self.status = DeploymentStatus.FAILED
        self.error_message = error

    def add_log(self, message: str) -> None:
        """Add a log entry. Creates new list to trigger SQLAlchemy mutation tracking."""
        current_logs = list(self.logs) if self.logs else []
        current_logs.append({
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "message": message
        })
        self.logs = current_logs


class FeedbackType(enum.Enum):
    """Types of user feedback."""
    GENERAL = "general"
    BUG = "bug"
    FEATURE = "feature"
    IMPROVEMENT = "improvement"


class Feedback(Base, TimestampMixin):
    """
    User feedback model.
    
    Stores feedback, bug reports, and feature requests from users.
    """
    __tablename__ = "feedback"

    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4())
    )
    user_id: Mapped[Optional[str]] = mapped_column(
        String(36),
        ForeignKey("users.id", ondelete="SET NULL"),
        nullable=True,
        index=True
    )
    feedback_type: Mapped[FeedbackType] = mapped_column(
        Enum(FeedbackType),
        default=FeedbackType.GENERAL,
        nullable=False
    )
    message: Mapped[str] = mapped_column(
        Text,
        nullable=False
    )
    page_url: Mapped[Optional[str]] = mapped_column(
        String(500),
        nullable=True
    )
    user_agent: Mapped[Optional[str]] = mapped_column(
        String(500),
        nullable=True
    )
    email: Mapped[Optional[str]] = mapped_column(
        String(255),
        nullable=True
    )
    status: Mapped[str] = mapped_column(
        String(50),
        default="new",
        nullable=False
    )

    # Relationships
    user: Mapped[Optional["User"]] = relationship("User", backref="feedback")

    # Indexes
    __table_args__ = (
        Index("idx_feedback_type", "feedback_type"),
        Index("idx_feedback_status", "status"),
        Index("idx_feedback_created", "created_at"),
    )

    def __repr__(self) -> str:
        return f"<Feedback(id={self.id}, type={self.feedback_type.value}, status={self.status})>"


class ContactSubmission(Base, TimestampMixin):
    """
    Contact form submissions.
    
    Stores messages from the public contact form.
    """
    __tablename__ = "contact_submissions"

    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4())
    )
    name: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )
    email: Mapped[str] = mapped_column(
        String(255),
        nullable=False
    )
    subject: Mapped[str] = mapped_column(
        String(100),
        nullable=False
    )
    message: Mapped[str] = mapped_column(
        Text,
        nullable=False
    )
    status: Mapped[str] = mapped_column(
        String(50),
        default="new",
        nullable=False
    )
    responded_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )

    # Indexes
    __table_args__ = (
        Index("idx_contact_status", "status"),
        Index("idx_contact_created", "created_at"),
    )

    def __repr__(self) -> str:
        return f"<ContactSubmission(id={self.id}, email={self.email}, subject={self.subject})>"


class OnboardingStatus(Base, TimestampMixin):
    """
    User onboarding progress tracking.
    
    Tracks which onboarding steps a user has completed.
    """
    __tablename__ = "onboarding_status"

    id: Mapped[str] = mapped_column(
        String(36),
        primary_key=True,
        default=lambda: str(uuid4())
    )
    user_id: Mapped[str] = mapped_column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        unique=True,
        nullable=False
    )
    email_verified: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )
    api_keys_added: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )
    first_app_generated: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )
    first_deploy: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )
    completed_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    dismissed: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        nullable=False
    )

    # Relationships
    user: Mapped["User"] = relationship("User", backref="onboarding")

    def __repr__(self) -> str:
        return f"<OnboardingStatus(user_id={self.user_id}, completed={self.completed_at is not None})>"

    def check_complete(self) -> bool:
        """Check if all onboarding steps are complete."""
        return all([
            self.email_verified,
            self.api_keys_added,
            self.first_app_generated,
            self.first_deploy
        ])

    def mark_complete_if_done(self) -> None:
        """Mark as complete if all steps are done."""
        if self.check_complete() and not self.completed_at:
            self.completed_at = datetime.now(timezone.utc)


# ==================== Subscription Models ====================

class SubscriptionTier(enum.Enum):
    """Subscription tier levels."""
    FREE = "free"
    STARTER = "starter"
    PROFESSIONAL = "professional"
    BUSINESS = "business"


class SubscriptionStatus(enum.Enum):
    """Subscription status."""
    ACTIVE = "active"
    CANCELED = "canceled"
    PAST_DUE = "past_due"
    TRIALING = "trialing"
    PAUSED = "paused"


class Subscription(Base, TimestampMixin):
    """User subscription model."""
    __tablename__ = "subscriptions"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    
    # Stripe fields
    stripe_customer_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    stripe_subscription_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    stripe_price_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    
    # Subscription details
    tier: Mapped[SubscriptionTier] = mapped_column(
        Enum(SubscriptionTier),
        default=SubscriptionTier.FREE
    )
    status: Mapped[SubscriptionStatus] = mapped_column(
        Enum(SubscriptionStatus),
        default=SubscriptionStatus.ACTIVE
    )
    
    # Usage limits
    app_generations_limit: Mapped[int] = mapped_column(default=1)
    app_generations_used: Mapped[int] = mapped_column(default=0)
    
    # Billing period
    current_period_start: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    current_period_end: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    cancel_at_period_end: Mapped[bool] = mapped_column(default=False)
    
    # Relationship
    user: Mapped["User"] = relationship(back_populates="subscription")


class APIKey(Base, TimestampMixin, SoftDeleteMixin):
    """API Key model for programmatic access."""
    __tablename__ = "api_keys"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    key_hash: Mapped[str] = mapped_column(String(255), nullable=False)  # Hashed API key
    key_prefix: Mapped[str] = mapped_column(String(10), nullable=False)  # First few chars for identification
    
    # Permissions and limits
    is_active: Mapped[bool] = mapped_column(default=True)
    rate_limit: Mapped[int] = mapped_column(default=1000)  # Requests per hour
    
    # Usage tracking
    last_used_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    total_requests: Mapped[int] = mapped_column(default=0)
    
    # Relationship
    user: Mapped["User"] = relationship(back_populates="api_keys")


class BusinessFormation(Base, TimestampMixin):
    """Business formation/registration model."""
    __tablename__ = "business_formations"

    id: Mapped[int] = mapped_column(primary_key=True)
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    project_id: Mapped[int] = mapped_column(ForeignKey("projects.id"), nullable=False)
    
    # Business details
    business_name: Mapped[str] = mapped_column(String(255), nullable=False)
    business_type: Mapped[str] = mapped_column(String(50), default="LLC")  # LLC, Corporation, etc.
    state: Mapped[str] = mapped_column(String(2), nullable=False)  # US state code
    
    # Registration status
    status: Mapped[str] = mapped_column(String(50), default="pending")  # pending, processing, completed, failed
    ein_number: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)
    formation_date: Mapped[Optional[datetime]] = mapped_column(
        DateTime(timezone=True),
        nullable=True
    )
    
    # External references
    external_order_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    
    # Relationships
    user: Mapped["User"] = relationship(back_populates="business_formations")
    project: Mapped["Project"] = relationship(back_populates="business_formation")
